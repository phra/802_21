\chapter{MIH-proxy}
\section{Descrizione}
{\em MIH-proxy} è un proxy ad alta affidabilità che permette di sfruttare più interfacce di rete per inviare e ricevere traffico ed è disponibili in due varianti: unidirezionale e bidirezionale. Nel primo, il trasmettitore può sfruttare più interfacce per inviare pacchetti UDP verso un peer remoto, il quale, per ovvie ragioni, non deve considerare l'IP sorgente, poiché i dati in arrivo potrebbero provenire da più IP sorgenti. Nel secondo, sia il trasmettitore, sia il ricevente possono aver più interfacce di rete su cui può passare traffico bidirezionale, occorre quindi una seconda istanza del proxy anche sul ricevente che si preoccupi di monitorare il traffico in arrivo su più interfacce ed è così possibile anche far collegare due applicazioni che usano TCP trasformando dapprima il flusso in pacchetti UDP, instradandolo sull'interfaccia corretta e ricostruendo il flusso originario una volta a destinazione. Si è deciso di tenere separati l'applicativo per trasformare un flusso TCP in pacchetti UDP e quello per gestire l'invio e ricezione sulle varie interfacce per delegare compiti appropriati e coerenti ad ogni componente, i quali potrebbero avere anche un utilizzo concreto anche se presi singolarmente.
\section{Funzionamento}
Entrambe le versioni del proxy sfruttano una implementazione open-source dello standard IEEE 802.21 per conoscere lo stato dei links disponibili. L'implementazione utilizzata è {\em ODTONE}\footnote{http://atnog.github.io/ODTONE/}. Sfortunatamente è solo un'implementazione parziale dello standard, ad esempio implementa solo alcuni degli eventi definiti nello standard tra quelli generabili da ogni interfaccia. 
\subsection{Unidirezionale}
La versione unidirezionale gestisce solo un traffico in uscita da più interfacce per limiti tecnici, ovvero, supponendo traffico bidirezionale, nel caso cadesse un'interfaccia del trasmettitore, il ricevente non saprebbe mai che l'IP da cui stava ricevendo non è più disponibile, trattandosi di pacchetti UDP, e quindi continuerebbe ad inviare ad un IP non raggiungibile. Per conoscere lo stato delle interfacce locali disponibili, il proxy rimane in ascolto di eventi {\em link\_down} e {\em link\_up} inviati dall'{\em MIHF} quando c'è un cambiamento di stato in una interfaccia, in modo da sapere attraverso quali interfacce poter inviare dati. 
\subsection{Bidirezionale}
La versione bidirezionale necessita di due istanze del proxy, poiché ognuna deve poter inviare e ricevere su più interfacce. Per conoscere lo stato locale si comporta come la versione unidirezionale, per lo stato del peer remoto è stato necessario introdurre un sistema di {\em heartbeat} temporizzato con pacchetti vuoti per segnalare alla controparte i links funzionanti. Se dopo un certo periodo non si ricevono pacchetti da un dato IP, quella destinazione viene contrassegnata {\em down} e quindi non si invieranno più dati verso quell'IP fino a quando non sarà ricevuto un pacchetto di {\em heartbeat}. In questo modo ogni istanza è a conoscenza dello stato delle interfacce di rete locali e remote. Per poter gestire il traffico generato da due applicazioni che si connettono tra loro tramite il protocollo TCP è possibile aggiungere un nuovo componente tra l'applicazione e il proxy in entrambi i peers che si occuperanno di trasformare il flusso TCP in datagrammi, gestire pacchetti persi, doppi o fuori ordine e ricostruire il flusso originario prima di consegnarlo al destinatario. Inoltre è possibile richiedere una cifratura {\em AES256} nella conversione da flusso a datagrammi.
\section{Possibili utilizzi}
Una volta ottenuta la possibilità di instradare su più interfacce il traffico, è naturale chiedersi quali possibili utilizzi possa avere questo progetto:
è possibile, ad esempio, stabilire una particolare politica di {\em scheduling} dei {\em sockets} da usare per effettuare {\em load balancing} del traffico sui vari canali disponibili oppure creare un canale ad alta affidabilità che utilizzi una interfaccia tra quelle disponibili, magari decidendone una preferita. Tutto ciò può essere effettuato semplicemente modificando le funzioni {\em interfaces::find\_best\_interface()} e {\em interfaces::find\_best\_destination()} nel codice.
\section{Sviluppi futuri}
In futuro si potrebbe pensare di aggiungere, ad esempio, una gestore aggiuntivo delle sole interfacce wireless in modo da utilizzare preferibilmente la connessione con il valore {\em RSSI} migliore, tenendo conto dell'entità dei diversi valori per ogni specifica tecnologia oppure implementare uno {\em scheduler} a priorità per l'instradamento del traffico. Inoltre si potrebbe delegare a dei moduli la gestione delle interfacce, in modo da facilitare l'implementazione e la convivenza di più algoritmi di {\em scheduling}.
